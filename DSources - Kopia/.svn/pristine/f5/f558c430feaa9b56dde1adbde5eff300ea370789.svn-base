using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UDM;


namespace DSources.Parsers
{
    internal class AbstractParser : InternalParser
    {
        public static String COLUMNS_ROLES_KEY = "Columns roles list";
        public static String COLUMN_OBJECT_TYPES_KEY = "Object type in columns";

        private ParserInfo _arguments = new ParserInfo();

        internal ParserCore ParserCore { get; set; }

        public ParserInfo Arguments { get { return _arguments; } }

        public virtual bool IsFinal { get { return false; } }

        public virtual bool IsValid { get { return false; } }

        public AbstractParser()
        {
            ParserCore = new ParserCore();
        }

        public virtual InternalParser ClonePrototype()
        {
            throw new NotImplementedException();
        }

        protected ObjectType[] objectTypes;
        protected DataType[] roles;

        public virtual void ConfigureItSelf(Logic.ParserConfiguration configuration)
        {
            if (Arguments.ContainsArgument(COLUMN_OBJECT_TYPES_KEY))
            {
                Console.WriteLine(configuration.GetProperty(COLUMN_OBJECT_TYPES_KEY).ToLower());
                string[] objectTypesNames = configuration.GetProperty(COLUMN_OBJECT_TYPES_KEY).ToLower().Split(',');

                foreach (string objectTypeName in objectTypesNames)
                {
                    if (!objectTypeName.Equals("text") && !objectTypeName.Equals("integer") && !objectTypeName.Equals("floating") && !objectTypeName.Equals("date"))
                    {
                        throw new ArgumentException();
                    }
                }
                objectTypes = objectTypesNames.Select(s => (s.Equals("text") ? ObjectType.Text : (s.Equals("integer") ? ObjectType.Integer : (s.Equals("floating") ? ObjectType.Floating : ObjectType.Date)))).ToArray();
            }
            if (Arguments.ContainsArgument(COLUMNS_ROLES_KEY))
            {
                Console.WriteLine(configuration.GetProperty(COLUMNS_ROLES_KEY).ToLower());
                string[] rolesNames = configuration.GetProperty(COLUMNS_ROLES_KEY).ToLower().Split(',');

                foreach (string roleName in rolesNames)
                {
                    if (!roleName.Equals("dimension") && !roleName.Equals("fact"))
                    {
                        throw new ArgumentException();
                    }
                }

                roles = rolesNames.Select(s => (s.Equals("fact")) ? DataType.Fact : DataType.Dimension).ToArray();
            }
            Console.WriteLine("abstract configured: " + roles + "|" + objectTypes);
        }

        public virtual void Init()
        {
            ParserArgumentInfo column_object_types = new ParserArgumentInfo(COLUMN_OBJECT_TYPES_KEY, ArgType.Text, "List of object types in columns, in format: \"<object_type> , <object_type> , (...)\" where <object_type> is one of: Text, Integer, Floating, Date");
            ParserArgumentInfo columns_roles = new ParserArgumentInfo(COLUMNS_ROLES_KEY, ArgType.Text, "List of role of each column, in format: \"<role> , <role> , (...)\" where <role> is one of: Fact, Dimension");

            Arguments.AddArgument(column_object_types);
            Arguments.AddArgument(columns_roles);
        }

        public bool RowsInFirstNest = true;

        public virtual Table Parse()
        {
            ParseData();
            return ParserCore.Build();
        }

        internal void ParseData()
        {
            ParserCore.Init();
            for (int i = 0; i < roles.Length; ++i)
            {
                ParserCore.SetColumnType(roles[i]);
                ParserCore.SetColumnObjectsType(objectTypes[i]);
                ParserCore.GotoNextColumn();
                
            }
            ParserCore.GotoStart();

            string data = ReadData();
            List<string> lines = SplitFirstNest(data);
            if (RowsInFirstNest)
            {
                parseFirstNestAsRows(lines);
            }
            else
            {
                parseFirstNestAsColumns(lines);
            }
        }

        internal virtual string ReadData()
        {
            throw new NotImplementedException();
        }

        internal virtual List<string> SplitFirstNest(string Data)
        {
            throw new NotImplementedException();
        }

        internal void parseFirstNestAsRows(List<string> lines)
        {
            foreach (String columnName in SplitSecondNest(lines.ElementAt(0)))
            {
                ParserCore.SetColumnName(columnName);
                ParserCore.GotoNextColumn();
            }
            ParserCore.GotoStart();
            foreach (String firstNest in lines.GetRange(1,lines.Count-1))
            {
                List<string> values = SplitSecondNest(firstNest);
                foreach (String value in values)
                {
                    ParserCore.AddCellInRowAndGoToNextColumn(value);
                }
                ParserCore.GotoNextRow();
            }
        }

        internal void parseFirstNestAsColumns(List<string> lines)
        {
            foreach (String firstNest in lines)
            {
                List<string> values = SplitSecondNest(firstNest);
                ParserCore.SetColumnName(values.ElementAt(0));
                foreach (String value in values.GetRange(1,values.Count-1))
                {
                    ParserCore.AddNextCellInColumn(value);
                }
                ParserCore.GotoNextColumn();
            }
        }

        internal virtual List<string> SplitSecondNest(string firstNest)
        {
            throw new NotImplementedException();
        }
    }
}
